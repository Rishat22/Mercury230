#ifndef CCOMMAND
#define CCOMMAND
#include <QString>
#include <QDateTime>
#include <QtSql>
// 01.10.2016 Класс параметра получаемого из LONGBLOB столбца в виде QList<CVarDB>
// 27.03.2017 Добавлен новый тип "bit" - где VarData - это номер бита (1-8) в байте
class CVarDB
{
public:
    CVarDB();
    quint32 VarIndex;      // Индекс переменной
    // Разрешения параметра:
    //            "READ" - только обработка переменной без записи значения в БД, но при этом допускается запись тревог и сообщений
    //            "CREATE" - разрешается запись переменной в таблицу даже если столбец отсутствует, т.е. будет создана заново со столбцами настроек, в случае если переменная существует данные настроек будут считаны из БД
    //            "WRITE" - запись только в уже созданный столбец, данные настроек скопируются из БД
    //            "COMMAND" - команда конфигурирования или управления (аналогична "WRITE" и "CREATE" с перезаписью данных настроек)
// 06.10.2016 Внимание при разрешении переменной WRITE при получении ответа из БД прибора будут считаны настройки переменной и по ним осуществляться дальнейшие действия
// В режиме WRITE и CREATE если в БД прибора есть настройки - некоторые настройки в таблице команд будут проигнорированы
    QString VarPermit;
    QString VarName;       // Имя столбца переменной в БД
    QString VarType;       // Тип данных к которым следует преобразовать байты из входного массива
    QString VarTypeSave;   // Формат в котором следует записать переменную в БД
    quint32 VarOffset;     // Сдвиг от начала во входном массиве
    quint32 VarData;       // Количество считываемых байт из входного массива
    QString VarInsert;     // Последовательность вставки байтов в переменную VarType
    QString VarSensor_MIN; // Минимальное значение датчика типа VarTypeSave
    QString VarSensor_MAX; // Максимальное значение датчика типа VarTypeSave
    QString VarParam_MIN;  // Минимальное значение параметра типа VarTypeSave
    QString VarParam_MAX;  // Максимальное значение параметра типа VarTypeSave
    QString VarBorder_MIN; // Минимальный порог срабатывания типа VarTypeSave разделенный "/" при нескольких значениях
    QString VarBorder_MAX; // Максимальный порог срабатывания типа VarTypeSave разделенный "/" при нескольких значениях
    quint8 AlarmSet;       // Флаг включения сигнализации
    QString AlarmMin;      // Текст сообщения при тревоги по низкому уровню разделенный "/" при нескольких значениях
    QString AlarmMax;      // Текст сообщения при тревоги по высокому уровню разделенный "/" при нескольких значениях
    quint8 SMSSet;         // Включение отправки СМС-при аварийном состоянии параметра
    // Номера телефонов на которые следует отправлять СМС в формате /*/*/12/12... - где первая * - (1 - отправлять, 0 - нет)
    //отправка на номера ответственных, вторая на номера операторов, дальше 12-значные номера дополнительных телефонов
    QString Telephones;
    quint8 StopFlag;       // Флаг остановки обработки ответа при ошибке параметра
};
Q_DECLARE_METATYPE(CVarDB)

// 01.10.2016 Класс команды получаемый из БД TCommands по "RequestType" и "ObjectID"
class CCommandDB
{
public:
// 1. Заголовок описания запроса
    quint32 ObjectID;             // Идентификатор объекта
    // Наименование прибора и его номер (определяет таблицы БД в которые будет записан результат)"TSRV-024/000234"
    // Также данное значения EqName+"/"+EqNumber проверяется с перечнем TObject->Equipment и в случае если данных прибора в перечне
    // нет, данные ответа в БД записаны не будут о чем будет выведено предупреждение
    QString EqName;
    QString EqNumber;
    QString EqNumberType;           // Тип номера прибора "QString", "quint8-32" и т.д.
    quint32 CID;                    // Идентификатор команды
    // Тип запроса для фильтра RequestCommands:
    // "CURRENT"   - запрос текущих параметров, может содержать разрешения переменных любого типа, но клиент не создает разрешения типа CREATE или COMMAND в данных запросах
    // "STATISTIC" - запрос статистики, может содержать разрешения переменных любого типа, но клиент не создает разрешения типа CREATE или COMMAND в данных запросах
    // "CONFIG_C" - запрос конфигурирования или управления оборудованием, может содержать переменные любых типов для изменения настроек параметров или создания новых в таблице текущих
    // "CONFIG_S" - запрос конфигурирования или управления оборудованием, может содержать переменные любых типов для изменения настроек параметров или создания новых в таблице статистики
    QString RequestType;
    // Тип команды:
    //             "STRIGHT"-прямая
    //             "PLC" -через плк
    //             "DRIVER(NAME)" -через драйвер с именем файла без расширения
    //             "TERMINAL(*)" - терминальная команда, где * - Y или N (через ПЛК -Y, напрямую -N)
    QString TypeCommand;
    quint32 Attempts;               // Сколько раз пытаться получить ответ на команду при установке статуса "TIMEOUT" или "ERROR" до того как она будет удалена из перечня
    quint32 CountCommand;           // Какое число раз следует отправить команду, где 0-бесконечно, остальные будут удалены после окончания
    quint32 Delay;                  // Время ожидания ответа от оборудования (мс) от 100 до 4294967295
    quint8 Priority;                // Приоритет команды, чем выше номер, тем раньше команда будет выполнена по отношению к другим
// 2. Настройки порта (используются только при передаче через ПЛК)
    unsigned char Funct;            // Номер функции для передачи оборудованию
    unsigned char PortNum;          // Номер последовательного порта
    unsigned char DataCom;          // Размера байта
    unsigned char StopBits;         // Число стоповых бит
    unsigned char ParityBits;       // Число стоповых бит
    quint32 SpeedCom;               // Скорость работы порта
// 3. Параметры для обработки ответов
    QList<CVarDB> Params;
// 4. Тело команды
    QByteArray Command;             // Двоичная команда
};

// 12.09.2016 Класс строки команды для таблицы команд
// Каждая отдельная команда имеет 28 полей, при этом если команды транслируются:
// 1- через ПЛК, то ответы пришедшие от ПЛК сопоставляются по CID и NUMBER с таблицей команд
// 2- напрямую, ответы от оборудования могут иметь специфический формат, поэтому будет произведен поиск соответствующих описаний
// среди команд со статусом "PROCESSING" - в обработке, "TIMEOUT" - кончилось время ожидания
// 3- через драйвер, ответы принимаются по внутренней логике драйвера

class CCommand
{
public:
    CCommand();
    // Инициализация объекта строки команды
    bool initCommand(quint32 ID, QString RequestType, QSqlQuery* mQuery);
    bool TestParameterSetup(CVarDB var);                   // Проверка 1 параметра
    bool initParameters();                                 // Проверка параметров
    bool TestVarInsert(QList<QChar> list, QString str);    // Проверка порядка записи байт в переменную
    bool TestVar(QString VarType, QString Var);            // Проверка параметра по типу
    bool TestVar(QString VarType, QByteArray Var);
    bool TestVarAlarm(QString VarType, QString Var);       // Проверка параметра по типу для нескольких значений разделенных "/"

    // Проверка типа команды
    bool IsTypeCommand(QString TypeCommand);
    CCommandDB DBData;              // Данные команды получаемые из БД
    quint32 BadAttempts;            // Число неудачных попыток
    quint32 Number;                 // Номер команды или сеансовый идентификатор по которому определяется ответ
    // Статус команды:
    //                "READY" - готова к запуску (устанавливается потоком обработки команд при создании команды)
    //                "PROCESSING" - в обработке (устанавливается потоком отправки)
    //                "COMPLETED" - завершена (устанавливается драйвером или функцией приема)
    //                "TIMEOUT" - вышло время ответа (устанавливается потоком обработки команд при проверке задержек)
    //                "ERROR" - ошибка (устанавливается драйвером или функцией приема/отправки при обнаружении каких-либо ошибок в данных)
    QString Status;
    QDateTime StartTime;            // Время отправки
    QDateTime FinishTime;           // Время окончания
    QByteArray Answer;              // Ответные данные, если нужны
};
#endif // CCOMMAND

